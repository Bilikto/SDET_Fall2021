// Used site ---> https://www.javatpoint.com

ABOUT JAVA:
- What is Java?
    Java is a programming language and a platform. Java is a high level, robust, object-oriented and secure programming language.
    Java was developed by Sun Microsystems (which is now the subsidiary of Oracle) in the year 1995.
    James Gosling ---> father of Java.

 A list of important features of Java:
    - Simple language;
    - Object-oriented programming language --> all are objects in Java (class, object + 4 principles);
    - Platform independent (write once, run anywhere ("platform" is hardware and software environment));
    - Secured --> we can develop virus-free systems. Java is secured because Java Programs run inside a virtual machine sandbox.
    - Robust (strong) --> Java uses strong memory management. Garbage collection is implemented.

 There are 4 editions of Java:
    1) Java SE (Java Standard Edition)
       It is a Java programming platform. It includes Java programming APIs such as java.lang, java.io, java.net, java.util, java.sql, java.math etc.
       It includes core topics like OOPs, String, Regex, Exception, Inner classes, Multithreading, I/O Stream, Networking, AWT, Swing, Reflection, Collection, etc.
    2) Java EE (Java Enterprise Edition)
       It is an enterprise platform that is mainly used to develop web and enterprise applications. It is built on top of the Java SE platform.
       It includes topics like Servlet, JSP, Web Services, EJB, JPA, etc.
    3) Java ME (Java Micro Edition)
       It is a micro platform that is dedicated to mobile applications.
    4) JavaFX
       It is used to develop rich internet applications. It uses a lightweight user interface API.


BASICS OF JAVA:
- Compilation Flow:
    javac (HelloWorld.java (Java Code))   -->   Compiler  --> java (HelloWorld.class (Byte Code))

- JDK, JRE and JVM:
    "JVM" (Java Virtual Machine) is an abstract machine. It is called a virtual machine because it doesn't physically exist. It is a specification that provides a
    runtime environment in which Java bytecode can be executed.
    "JRE" (Java Runtime Environment). The JRE is a set of software tools which are used for developing Java applications. It is used to provide the runtime environment.
    It is the implementation of JVM. It physically exists. It contains a set of libraries + other files that JVM uses at runtime.
    "JDK" (Java Development Kit). The JDK is a software development environment which is used to develop Java applications.
    It physically exists. It contains JRE, JVM + development tools (javac, java etc).


VARIABLES:
    A "variable" is a container which holds the value while the Java program is executed. It is a combination of "vary + able" which means its value can be changed.
    A variable is assigned with a data type. Variable is a name of memory location. There are three types of variables in java: local, instance and static.
    - "Local": Variable created inside any blocks (for loop, methods, if condition), or not declared at class level are the local variables
               Local variable can be accessible only inside the blocks where it is created
               Local variable can not be static & can not be private, public
               Local variable must be initialized before use
               Local variable can be final
    - "Instance": Variable created at class level without static keyword are the instance variables
                  It belongs to the objects
                  Instance variable initialized by default (default value for int - 0 & String - null)
                  Instance variable can be private, public
                  Instance variable can be final
                  Instance variable will have multiple copies with respect to number of object we're creating from class
    - "Static": Variable created at class level with static keyword are the Static variables
                It belongs to the class
                Static variable initialized by default (default value for int - 0 & String - null)
                Static variable can be private, public
                Static variable will have single copy at class level regardless of number of object we're creating from class
                Static variable can be final


DATA TYPES:
"Primitive" (8 data types)
byte, short, int, long, double, float, boolean, char.

"Non-Primitive" (reference types)
Classes, Interfaces, and Arrays.


OPERATORS:
There are many types of operators in Java:
"Unary" Operator --> postfix (expr++, expr--)
                 --> prefix (++expr, --expr)
"Arithmetic" Operator --> multiplicative (*, /, %)
                      --> additive (+, -)
"Shift" --> shift (<<, >>, >>>)
"Relational" --> comparison (<, >, <=, >=, instanceof)
             --> equality (==, !=)
"Bitwise" --> AND (&)
          --> exclusive OR (^)
          --> inclusive OR (|)
"Logical" --> AND (&&)
          --> OR (||)
"Ternary" --> ternary (? :)
"Assignment" --> (=, +=, -=, *=, /=, %=, &=, ^=, |=, <<=, >>=, >>>=)


DATA TYPE CASTING:
data type casting --> is converting one data type to another.
- "Implicit" [automatically] -> it happens automatically when we convert from smaller to larger data type;
- "Explicit" [manually] -> when we convert from larger to smaller data type, because we might loose some value in our data
    EX: Explicit type casting - from double to int
        double d1 = 12.34;
        int i = d1 -> incompatible types compile error and in order to fix this we need to manually type cast it as follows
        int i = (int) d1;


AUTOBOXING and UNBOXING:
"Autoboxing" ---> is converting primitive to wrapper class objects; Ex: byte to Byte, char to Character.
"Unboxing" is converting from wrapper object to primitive.
Do not need to use the "intValue()" method of wrapper classes for "Autoboxing" and "Unboxing".


CONTROL FLOW STATEMENTS:
Java provides 3 types of control flow statements:
1. Decision Making statements (conditional statements)
    - if, if-else statements
    - switch statements
2. Loop statements
    - do_while loop
    - while loop
    - for loop
    - for_each loop
3. Jump statements
    - break statement
    - continue statement

"Decision Making statements" decide which statement to execute and when. It evaluates condition to Boolean expression.
Ex: if(true) {...}
"Switch" statement supports --> byte, short, int, char, Byte, Short, Integer, Character, String and enumeration.
It doesn`t support --> double, float, boolean.
The case value must be literal or constant! It doesn't allow variables.
Ex: switch(expr) {
        case value1: // --> value1 must be final value! it can not be expression!
            statement1;
            break;
        .
        .
        case valueN:
            statementN;
            break;
        default:
            default statement;
}

"Loop statements" are used to execute the set of instructions in a repeated order.
"for loop": ---> for(int i = 0; i < 10; i++) {..}
We use the "for loop" only when we exactly know the number of times, we want to execute the block of code.

"for-each loop": ---> for(data_type var: array/collection) {...}
Java provides an enhanced for loop to traverse the data structures like array or collection. In the for-each loop, we don't need to update the loop variable.

"while loop" ---> while(condition) {...}
If we don't know the number of iterations in advance, it is recommended to use a "while" loop

"do_while loop" ---> do { statements } while(condition)
When the number of iteration is not known and we have to execute the loop at least once, we can use do-while loop.

"Jump statements" are used to transfer the execution control to the other part of the program.
"break" ---> is used to break the current flow of the program and transfer the control to the next statement outside a loop or switch statement. However, it breaks only
             the inner loop in the case of the nested loop. The break statement cannot be used independently, it can only be written inside the loop or switch statement.
"continue" ---> doesn't break the loop, it skips the specific part of the loop and jumps to the next iteration of the loop immediately.


COMMENTS IN JAVA
Single line comment --> //
Multiline comment   --> /*...*/
Java Documentation comment -->   /**  (usually used to write large programs for a project or software
                                 *    application as it helps to create documentation API)
                                 *
                                 * @author Bilikto
                                 * @version 1.8
                                 * @since 01/05/2022
                                 */

OOP CONCEPTS
 -Object
 -Class
 -Method
 -Constructor
 -Static keyword
 -Types of Variables(Local, Static, Instance)
 -Inheritance
 -Polymorphism
 -Abstraction
 -Encapsulation
There are some other terms which are used in OOP:
 -Coupling (when a class has the details information of another class, it arises when classes are aware of each other)
 -Cohesion (It refers to the level of a component which performs a single well-defined task)
 -Association (It represents the relationship between the objects)
 -Aggregation (It represents the relationship where one object contains other objects as a part of its state. It is also termed as a HAS-A relationship in Java)
 -Composition (The composition represents the relationship where one object contains other objects as a part of its state.  There is a strong relationship between the containing object and the dependent object.
               If you delete the parent object, all the child objects will be deleted automatically)

Object
Objects is any entity that has state abd behaviour (Ex: a chair, pen, table, dog, cat). It is an instance of a class.

Class
Class is collection of objects. It is a blueprint from which you can create an individual object.

Inheritance --> when one object acquires all the properties and behaviors of parent object
	-extends keyword
	-Constructor Chaining
	-"this" keyword
	-"super" keyword

Polymorphism
	-Method Overloading
	-Method Overriding
	-Dynamic Polymorphism / Run Time Polymorphism

Encapsulation
    -Access modifier
    -Getters & Setters

Abstraction
    -Abstract Class
    -Interface

Exception Handling
    -try_catch_finally

Generics
    -<T>

OOP vs PROCEDURE-ORIENTED PROGRAMMING
1. OOPs makes development and maintenance easier, whareas, in a POP it is not easy to mange if code grows as project size increase.
2. OOPs provides data hiding, whereas, in a procedure-oriented programming language, global data can be accessed from anywhere
3. OOPs provides the ability to simulate real-world event much more effectively. We can provide the solution of real word problem if we are using the OOP language.

NAMING CONVENTION
Start with the uppercase letter:
Class --> It should be a noun such as Color, Button, System, Thread, etc.
Interface --> It should be an adjective such as Runnable, Remote, ActionListener.
Start with lowercase letter:
Method --> It should be a verb such as main(), print(), println().
Variable --> It should not start with the special characters like & (ampersand), $ (dollar), _ (underscore).

Package --> It should be a lowercase letter such as java, lang. Multiple words are separated by dots (.) such as java.util.
Constant --> It should be in uppercase letters such as RED, YELLOW. Multiple words are separated an underscore(_) such as MAX_PRIORITY.
 +  camelCase!

OBJECTS
Object is any entity that has state and behavior. Ex: chair, pen, table etc.
An object is an instance of a class.
"State" --> represents the data(value) of an object
"Behavior" --> represents the behaviour(functionality) of an object
"Identity" --> every object has a a unique ID which is used by JVM to identity each object.

CLASS
It is a template or blueprint from which objects are created.
Class contains:
-Fields
-Methods
-Constructors
-Blocks
-Nested class and interface

INSTANCE VARIABLE (from Chirag class)
---> a variable which is created inside the class but outside the method, at class level
---> It doesn't get memory at compile time. It gets memory at runtime when an object or instance is created!
---> It belongs to the objects
---> Instance variable initialized by default (default value for int - 0 & String - null)
---> Instance variable can be private, public
---> Instance variable can be final
---> Instance variable will have multiple copies with respect to number of object we're creating from class


METHOD
In Java, a "method" is a block of code or collection of statements or a set of code grouped together to perform a certain task or operation.
Advantage of Method:
-Code Reusability --> we write a method once and use it many times. We do not require to write code again and again.
-Code Optimization --> we can easily modify code by adding and removing a chunk of code.
Method declaration:
access modifier, return type, methodName, parameterList, method body.
public int sum(int a, int b) {...body...}

Method signature:
Every method has a "method signature". It is a part of the "method declaration". It includes the method name and parameter list.
Access Modifiers (specifier):
- Public --> The method is accessible by all classes when we use public specifier in our application (even in different packages)
- Private --> The method is accessible only in the classes in which it is defined
- Protected --> The method is accessible within the same package or subclasses in a different package
- Default (Package private) --> The method is visible only from the same package only. It is set by default, when we do not use any access modifiers.

Return Type:
Return type is a data type that the method returns. If the method does not return anything, we use "void" keyword.

There are two types of methods:
1. Predefined (or built-in) methods --> method that is already defined in the Java class libraries (Ex: length(), equals(), compareTo()..);
2. User-defined methods --> method is written by programmer.

Static method
A method that has "static" keyword is known as static method. In other words, a method that belongs to a class rather than an instance
of a class is known as a "static method". The main advantage of a static method is that we can call it without creating an object.
It can access "static" data members and also change the value of it. The best example of a static method is the main() method.

Instance method
The method of the class is known as an "instance method". It is a non-static method defined in the class.
Before calling or invoking the instance method, it is necessary to create an object of its class.
There two types of instance methods:
1. Accessor (or getters) method -->  It is used to get the value of the private field.
2. Mutator (or setters) method --  It is used to set the value of the private field. It does not return anything.

Abstract method
The method that does not has method body is known as "abstract method". In other words, without an implementation is known as "abstract method".
It always declares in the abstract class. If class uses abstract method it MUST be "abstract" Class.
To create an abstract method, we use the keyword "abstract".

Factory method
It is a method that returns an object to the class to which it belongs. All static methods are factory methods.
For example, NumberFormat obj = NumberFormat.getNumberInstance();


========================================================================================================
01/08/2022
Revision class with Chirag!

We can not override static methods it belongs to class!
Ex: Parent p = new Child();
    p.method(); // --> if the method is overridden parent object "p" will call "static" method of parent class

We can not override variables! // --> parent object will call variable of parent class!

If Constructor is "private" we can not instantiate class.. we will get compilation error!

We can not use static methods and vars inside methods. Only at Class level.

We can not call from static methods non - static method and variables.
========================================================================================================


"NEW" Keyword
The new keyword is used to allocate memory at runtime. All objects get memory in Heap memory area.

3 ways to INITIALIZE object
1. By reference variable
    Ex:  Student s1=new Student();
         s1.id=101;
2. By method
    Ex:  Student s1=new Student();
         s1.initializerMethod(101);
3. By constructor

5 ways TO CREATE an object
1. By new keyword
2. By newInstance() method
3. By clone() method
4. By deserialization
5. By factory method


ANONYMOUS OBJECT
Anonymous simply means nameless. An object which has no reference is known as an anonymous object. It can be used at the time of object creation only.
If you have to use an object only once, an anonymous object is a good approach.
Ex: new Calculator().method(); //we can call method through anonymous object


CONSTRUCTOR
Constructor is a block of codes similar to the method. It is called when an instance of the class is created.
At the time of calling constructor, memory for the object is allocated in the memory.
Constructor is used to initialize the object variables.
Constructor RULES:
1. Constructor name must be the same as its class name.
2. A Constructor must not have return type.
3. A Constructor cannot be abstract, static, final and synchronized.
4. A Constructor can have access modifier - public, private, protected, default .

Every time when an object is created using the "new" keyword, at least one constructor is called.
1. "Default" constructor --> if there is no constructor available in the class.
2. "No-arg" constructor --> explicit constructor added by developer. We can write any statements inside explicit constructor
3. "Parametrized" constructor --> explicit constructor added by developer which takes parameter from user.
                                When we create an object of class we have to pass parameters to the constructor.

What is the purpose of a default constructor?
The default constructor is used to provide the default values to the object like 0, null, etc., depending on the type.
Why use the parameterized constructor?
The parameterized constructor is used to provide different values to distinct objects. However, you can provide the same values also.

Constructor overloading
"Constructor overloading" in Java is a technique of having more than one constructor with different parameter lists.

STATIC KEYWORD
The "static" keyword in Java is used for memory management mainly (it saves memory).
We can use "static" keyword with:
 1.variables,   3. blocks,
 2. methods,    4. nested classes.
The static keyword belongs to the class than an instance of the class.

Static variable
Any variable with static keyword is known as "static variable".
It'll create single copy at class level regardless of how many objects we're creating from class. Example - Family Income or College name of students.
The static variable gets memory only once in the class area at the time of class loading.
Java static variable is shared to all objects!!!
 EX:
    1. Program of the counter with NON-static variable
    In this example, we have created an instance variable named count which is incremented in the constructor.
    Since instance variable gets the memory at the time of object creation, each object will have the copy of the instance variable.
    class Counter{
        int count=0; //will get memory each time when the instance is created
        Counter(){
            count++;//incrementing value
            System.out.println(count);
        }

        public static void main(String args[]){
            Counter c1=new Counter(); //1
            Counter c2=new Counter(); //1
            Counter c3=new Counter(); //1
        }
    }
    Output: 1, 1, 1

    2. Program of counter by STATIC variable
    class Counter{
        static int count=0; //will get memory only once and retain its value
        Counter(){
            count++;//incrementing value
            System.out.println(count);
        }

        public static void main(String args[]){
            Counter c1=new Counter(); //1
            Counter c2=new Counter(); //2
            Counter c3=new Counter(); //3
        }
    }
    Output: 1, 2, 3

Static Variables (from Chirag class)
---> Variable created at class level with static keyword are the Static variables
---> It belongs to the class
---> Static variable initialized by default (default value for int - 0 & String - null)
---> Static variable can be private, public
---> Static variable will have single copy at class level regardless of number of object we're creating from class
---> Static variable can be final

*** Instance variable will get created in the memory when we create an object of the class
*** We don't required to create an object to call the static methods

Static method
If you apply static keyword with any method, it is known as "static method".
 - A static method belongs to the class rather than the object of a class.
 - A static method can be invoked without the need for creating an instance of a class.
 - A static method can access ONLY static data member and can change the value of it.
Restrictions for static methods:
1. The static method can not use non static data member or call non-static method directly
2. "this" and "super" cannot be used in static context.

Static block
 - Is used to initialize the static data member.
 - It is executed before the main method at the time of classloading.
Ex: class A2{
      static{
        System.out.println("static block is invoked");
      }
      public static void main(String args[]) {
        System.out.println("Hello main");
      }
    }
Output: static block is invoked
        Hello main

LOCAL VARIABLES
---> Variable created inside any blocks (for loop, methods, if condition), or not declared at class level are the local variables
---> Local variable can be accessible only inside the blocks where it is created
---> Local variable can not be static & can not be private, public
---> Local variable must be initialized before use
---> Local variable can be final


"THIS" KEYWORD
(from Chirag class)
---> It's reference variable that refers to the current object
---> This keyword can be used to access current class instance variables & methods
---> this() keyword also used to call current class constructor from another current class constructor

Rules of calling current class constructor from another constructor :
1. this() --> will call no argument constructor & IT SHOULD BE THE FIRST STATEMENT ONLY
2. this("data") --> will call parameterized constructor with String parameter

Here is given the 6 usage of java "this" keyword:
  1. this can be used to refer current class instance variable
  2. this can be used to invoke current class method (implicitly)
  3. this() can be used to invoke current class constructor.
  4. this can be passed as an argument in the method call.
  5. this can be passed as argument in the constructor call.
  6. this can be used to return the current class instance from the method.

Using "this" keyword we can distinguish local variable (parameters) and instance variable. Ex: this.name = name;
If local variables(arguments) and instance variables are different, there is no need to use this keyword.

You may invoke the method of the current class by using the this keyword.
If you don't use the this keyword, compiler automatically adds this keyword while invoking the method.

The this() constructor call can be used to invoke the current class constructor. It is used to reuse the constructor.
In other words, it is used for constructor chaining.

Rule: Call to this() must be the first statement in constructor!

this: to pass as an argument in the method
The this keyword can also be passed as an argument in the method. It is mainly used in the event handling.
Ex: class S2{
      void m(S2 obj){
        System.out.println("method is invoked");
      }
      void p(){
        m(this);
      }
      public static void main(String args[]){
        S2 s1 = new S2();
        s1.p();
      }
    }
Output: method is invoked

this: to pass as argument in the constructor call
We can pass the this keyword in the constructor also. It is useful if we have to use one object in multiple classes.
Ex: class B{
        A4 obj;
        B(A4 obj){
            this.obj=obj;
        }
        void display(){
            System.out.println(obj.data);//using data member of A4 class
        }
    }

    class A4{
        int data=10;
        A4(){
            B b=new B(this);
            b.display();
        }
        public static void main(String args[]){
        A4 a=new A4();
        }
    }
Output: 10

this: can be used to return current class instance
We can return this keyword as an statement from the method. In such case, return type of the method must be the class type (non-primitive).
Ex: lass A{
        A getA(){ <--- method with return type!
        return this;
        }
        void msg(){System.out.println("Hello java");}
    }
    class Test1{
        public static void main(String args[]){
            new A().getA().msg();
        }
    }
Output: Hello java

INHERITANCE (IS-A)
"Inheritance" in Java is a mechanism in which one object acquires all the properties and behaviors of a parent object. It is an important part of OOP.
When you inherit from an existing class, you can reuse methods and fields of the parent class. Moreover, you can add new methods and fields in your current class also.
Inheritance represents the "IS-A" relationship which is also known as a parent-child relationship. Ex: Bird IS-A Animal (It means that Bird is a type of Animal)
Why use inheritance in java?
1. For Method Overriding (so runtime polymorphism can be achieved).
2. For Code Reusability.

How can we achieve inheritance in java - Using "extends" keyword.
The meaning of "extends" is to increase the functionality.

NOTE!
In java programming, multiple inheritance is not supported through "class" byu multiple inheritance is supported through "interface" only!

Aggregation (HAS-A)
If a class have an entity reference, it is known as "Aggregation". Aggregation represents "HAS-A" relationship.
For example, Employee object contains many informations such as id, name, emailId etc. It contains one more object named Address, which contains
its own informations such as city, state, country, zipcode etc. as given below.
class Employee{
    int id;
    String name;
    Address address;  // Address is a class
    ...
}
In such case, Employee has an entity reference address, so relationship is Employee HAS-A address.

Why use Aggregation?
- For Code Reusability, when there is no is-a relationship.

ConstructorChaining (from Chirag class)
---> When we create object of child class it'll call parent class constructor first & then it'll call
child class constructor. This is called "Constructor Chaining".
---> For Example we have parent class A---> B (child of A) ---> C (child of B)
---> When we create object of class C then it'll call constructor of A first & then constructor of B and then it'll call constructor of C.


POLYMORPHISM
There are two types of polymorphism in Java: compile-time polymorphism and runtime polymorphism.
We can perform polymorphism in java by method "overloading" and method "overriding".

"METHOD OVERLOADING" (compile-time (static) polymorphism)
"Method Overloading" --> when a class has multiple methods with same name but different parameters.
Advantage of method overloading:
- Method overloading increases the readability of the program.
There are two ways to overload the method in java
1. By changing number of arguments
2. By changing the data type
In Java, Method Overloading is not possible by changing the return type of the method only.

Can we overload java main() method?
Yes, by method overloading. You can have any number of main methods in a class by method overloading.
But JVM calls main() method which receives string array as arguments only!

Method Overloading and Type Promotion
One type is promoted to another implicitly if no matching datatype is found.
The "byte" can be promoted to short, int, long, float or double.
The "short" datatype can be promoted to int, long, float or double.
The "char" datatype can be promoted to int,long,float or double and so on.
If there are matching type arguments in the method, type promotion is not performed!!!

"METHOD OVERRIDING" (run-time polymorphism)
"Method overriding" --> when a subclass (child class) has the same method as declared in the parent class.
In other words, If a subclass provides the specific implementation of the method that has been declared by one of its parent class, it is known as "method overriding".
Usage of Java Method Overriding
- Method overriding is used to provide the specific implementation of a method which is already provided by its superclass.
- Method overriding is used for runtime polymorphism

Rules for Java Method Overriding:
1. The method must have the same name as in the parent class
2. The method must have the same parameter as in the parent class.
3. There must be an IS-A relationship (inheritance).
4. The method in the child class must be at least as accessible or more accessible than the method in the parent class.

Can we override static method?
No, a static method cannot be overridden. It is because the static method is bound with class whereas instance method is bound with an object.
Static belongs to the class area, and an instance belongs to the heap area.

Difference between "method overloading" and "method overriding"
        "Method Overloading"                                                               "Method Overriding"
1. Method overloading is used to increase the "readability"                1. Method overriding is used "to provide the specific implementation of the method"
   of the program.                                                            that is already provided by its super class.
2. Method overloading is performed within class.                           2. Method overriding occurs in two classes that have IS-A (inheritance) relationship.
3. In case of method overloading, parameter must be different.             3. In case of method overriding, parameter must be same.
4. Method overloading is the example of "COMPILE TIME" polymorphism.       4. Method overriding is the example of "RUN TIME" polymorphism.
5.  Return type can be same or different in method overloading.            5. Return type must be same or covariant in method overriding.

"COVARIANT Return Type"
Before Java5, it was not possible to override any method by changing the return type. But now, since Java5, it is possible to override method by changing the return type
if subclass overrides any method whose return type is Non-Primitive but it changes its return type to subclass type.
Ex: class A{
        A get(){return this;}
    }

    class B1 extends A{
        @Override
        B1 get(){        // ---> if I write here A get() {..} in the main method we need to typecasting like ((B1)B1().get()).message();
            return this;
        }
        void message(){
            System.out.println("welcome to covariant return type");
        }

        public static void main(String args[]){
            new B1().get().message();
        }
    }
Output: welcome to covariant return type
In this example, the return type of the get() method of A class is A but the return type of the get() method of B class is B.
Both methods have different return type but it is method overriding. This is known as "covariant return type".
Advantages:
1. Covariant return type assists to stay away from the confusing type casts in the class hierarchy and makes the code more usable, readable, and maintainable.
2. In the method overriding, the covariant return type provides the liberty to have more to the point return types.
3. Covariant return type helps in preventing the run-time ClassCastExceptions on returns.


SUPER KEYWORD
1) It's a reference variable refers to object of parent class
2) Super keyword can be used to access parent class variables & methods
3) Super keyword also used to call parent class constructor from child class constructor

The super keyword in Java is a reference variable which is used to refer immediate parent class object.
Whenever you create the instance of subclass, an instance of parent class is created implicitly which is referred by super reference variable
Usage of Java super Keyword
1. super can be used to refer immediate parent class instance variable. --> if parent class and child class have same variables
2. super can be used to invoke immediate parent class method. --> It should be used if subclass contains the same method as parent class (overridden method).
3. super() can be used to invoke immediate parent class constructor. --> if there is no super() or this() it will added in each class constructor automatically by compiler.


INSTANCE INITIALIZER BLOCK
Instance Initializer block is used to initialize the instance data member. It run each time when object of the class is created.
What is the use of instance initializer block while we can directly assign a value in instance data member? Why use instance initializer block?
Suppose I have to perform some operations while assigning value to instance data member e.g. a for loop to fill a complex array or error handling etc.
There are three places in java where you can perform operations:
- method
- constructor
- block
What is invoked first, instance initializer block or constructor? (see InitializerBlockExample.java)
 The java compiler copies the code of instance initializer block in every constructor!!!

There are mainly three RULES for the instance initializer block. They are as follows:
1. The instance initializer block is created when instance of the class is created.
2. The instance initializer block is invoked after the parent class constructor is invoked (i.e. after super() constructor call).
3. The instance initializer block comes in the order in which they appear.


FINAL KEYWORD
The final keyword in java is used to restrict the user. The java final keyword can be used in many context.
Final can be:
- variable
- method
- class

The "final" keyword can be applied with the variables, a final variable that have no value it is called "blank final variable" or "uninitialized final variable".
It can be initialized in the constructor only. The blank final variable can be static also which will be initialized in the "static block" only --> static {data = 50}

final variable
If you make any variable as final, you cannot change the value of final variable(It will be constant)
final method
If you make any method as final, you cannot override it.
final class
If you make any class as final, you cannot extend it.

Is final method inherited?
Yes, final method is inherited but you cannot override it.
What is final parameter?
If you declare any parameter as final, you cannot change the value of it.
Ex: class Bike11{
      int cube(final int n){
      n = n + 2;    // can't be changed as n is final
      n * n * n;
    }
    public static void main(String args[]){
      Bike11 b=new Bike11();
      b.cube(5);
      }
    }
Can we declare a constructor final?
No, because constructor is never inherited.


RUNTIME (DYNAMIC) POLYMORPHISM
"Runtime polymorphism" or "Dynamic Method Dispatch" is process when an overridden method is called through the reference variable of a superclass.
Let's first understand the upcasting before Runtime Polymorphism:

"Upcasting"
If the reference variable of Parent class refers to the object of Child class, it is known as "upcasting".
class A{}
class B extends A{}
A a=new B(); //upcasting
In this example B IS-A A and B IS-A Object --> since Object is the root class of all classes in Java.
For upcasting, we can use the reference variable of class type or an interface type.

NOTE!
A method is overridden, not the data members, so runtime polymorphism can't be achieved by data members!

STATIC BINDING and DYNAMIC BINDING
Connecting a method call to the method body is known as "binding".
There are two types of binding
1. Static Binding (also known as Early Binding).
2. Dynamic Binding (also known as Late Binding).
Understanding types
Each variable has a type, it may be primitive and non-primitive (ex: int num = 30 --> here num variable is a type of int);
Each references have a type (ex: Dog d1; --> //here d1 is a type of Dog)
Each Objects have a type (ex: Dog d1 = new Dog(); --> //here d1 is an instance of Dog class, but it is also an instance of Animal (if extends))

Static Binding
When type of the object is determined at compiled time (by the compiler, not JVM), it is known as "static binding".
If there is any private, final or static method in a class, there is static binding.

Dynamic Binding
When type of the object is determined at run-time, it is known as "dynamic binding".
class Animal{
 void eat(){System.out.println("animal is eating...");}
}

class Dog extends Animal{
 void eat(){System.out.println("dog is eating...");}
 public static void main(String args[]){
  Animal a=new Dog();
  a.eat();
 }
}
In the above example object type cannot be determined by the compiler, because the instance of Dog is also an instance of Animal.
So compiler doesn't know its type, only its base type.


INSTANCEOF() OPERATOR
The "instanceof" operator is used to test whether the object is an instance of the specified type (class or subclass or interface).
The instanceof in java is also known as "type comparison operator" because it compares the instance with type. It returns either true or false.
If we apply the instanceof operator with any variable that has null value, it returns false.
Ex: simple instanceof Simple //true
An object of subclass type is also a type of parent class.
Ex: if Dog extends Animal then object of Dog can be referred by either Dog or Animal class.
dog instanceof Animal //true

Downcasting with instanceof
When Subclass type refers to the object of Parent class, it is known as "downcasting".
If we perform it directly, compiler gives Compilation error. --> Dog d=new Animal(); // ---> Compilation error
If you perform it by typecasting, ClassCastException is thrown at runtime. --> Dog d=(Dog)new Animal(); // ---> Compiles successfully but ClassCastException is thrown at runtime
But if we use "instanceof" operator, downcasting is possible!
class Animal { }
class Dog3 extends Animal {
  static void method(Animal a) {
    if(a instanceof Dog3){
       Dog3 d = (Dog3) a;  //---> downcasting
       System.out.println("ok downcasting performed");
    }
  }

  public static void main (String [] args) {
    Animal a = new Dog3(); //---> if "Animal a = new Animal()" will throw ClassCastException
    Dog3.method(a);
  }
}
Output:ok downcasting performed
Downcasting can also be performed without the use of "instanceof" operator if the actual object that is referred by "a", is an object of Dog class.
But, if we point to "a" reference of Parent class we will get ClassCastException.


ABSTRACTION
- Abstract class
- Interface

Before learning the Java abstract class, let's understand the "abstraction in Java" first.
"Abstraction" is a process of hiding the implementation details and showing only functionality to the user.
Another way, it shows only essential things to the user and hides the internal details, for example, sending SMS where you type the text and send the message.
You don't know the internal processing about the message delivery.
Abstraction lets you focus on what the object does instead of how it does it.
There are two ways to achieve abstraction in java
1. Abstract class (0 to 100%)
2. Interface (100%)

ABSTRACT CLASS
A class which is declared as abstract is known as an "abstract class". It can have abstract and non-abstract methods (method with the body).
It needs to be extended and its method implemented. It cannot be instantiated.

Points to Remember:
1. An abstract class must be declared with an "abstract" keyword.
2. It can have abstract and non-abstract methods (0 --> 100%).
3. If we have at least one abstract method in the class we need make class abstract.
4. It cannot be instantiated.
5. It can have constructors / instance variable & constructor will get executed when we create  object of child class
6. and static methods also.
7. It can have final methods which will force the subclass not to change the body of the method.
8. If you are extending an abstract class that has an abstract method, you must either provide the implementation of the method or make this class abstract.

Abstract Method
A method which is declared as abstract and does not have implementation is known as an "abstract method".

The abstract class can also be used to provide some implementation of the interface.
In such case, the end user may not be forced to override all the methods of the interface.
interface A{
    void a();
    void b();
    void c();
}

abstract class B implements A{
    public void b() {System.out.println("I am b");}
}

class M extends B{
public void a() {System.out.println("I am a");}
public void c() {System.out.println("I am c");}
}

class Test5{
    public static void main(String args[]){
        A a=new M();
        a.a();
        a.b();
        a.c();
}}

Output: I am a
        I am b
        I am c


INTERFACE
What's interface?
1) We cannot create object of interface
2) It can have only abstract methods --> 100% abstraction
3) By default variables are public static & final and methods are public & abstract
4) We can't have constructor in interface
5) When we implement an interface in a class, implemented methods of interface has to public
6) Class can implement more than one interface at a time
7) We need use implement keyword when we're implement interface in any class but interface we can
extends into another interface
8) Interface variables must be initialized at the time of declaration only
9) Child class has to implement all methods of interface or child class needs to declare abstract
10. It allows us to achieve multiple inheritance in Java

=========================================================================================================
		Difference between abstract class & interface
=========================================================================================================

Abstract class 					    Interface
1) 0-100 abstraction				1) 100% abstract
2) abstract keyword				    2) Interface keyword to declare
3) Constructor - Yes				3) Constructor - No
4) Class cannot extends more than	4) Class can implement any number of interface
   one abstract class
5) Extended					        5) Implemented
6) Instance  - Yes					6) Instance variable - No

WRAPPER class
The eight primitive types has its own object representatives.
The eight classes of the java.lang package are known as "wrapper classes" in Java.
"Autoboxing" ---> is converting primitive to wrapper class objects; Ex: byte to Byte, char to Character.
"Unboxing" is converting from wrapper object to primitive.
Do not need to use the "intValue()" method of wrapper classes for "Autoboxing" and "Unboxing".


ARRAY
"Array" is an object which contains elements of a similar data type.
We can store only a fixed set of elements in a Java array.
We can store primitive values or objects in an array.
Array is index-based, the first element of the array is stored at the 0 index, second element is stored on 1st index and so on.
We can get the length of the array using the length member.
There are two types of array:
    Single Dimensional Array
    Multidimensional Array


PASS BY VALUE and PASS by Reference
There is only PASS BY VALUE in java, not PASS BY REFERENCE.
If we call a method passing a value, it is known as "pass/call by value".
The changes being done in the called method, is not affected in the calling method.


STRING
String is an object that represents sequence of characters. An array of characters works same as Java string.
Java String class provides a lot of methods to perform operations on strings such as: compare(), concat(), equals(), split(), length(), charAt(),
                                                                                      replace(), compareTo(), intern(), substring(), toUpperCase(), toLowerCase() etc.
The "CharSequence" interface is used to represent the sequence of characters. String, StringBuffer and StringBuilder classes implement it.
It means, we can create strings in Java by using these three classes.
The Java String is immutable which means it cannot be changed. Whenever we change any string, a new instance is created.
For mutable strings, you can use StringBuffer and StringBuilder classes.
There are two ways to create String object:
                                            By string literal using double quotes --> "String constant pool"
                                            By new keyword ---> "Java Heap Memory"
Why String objects are immutable in Java?
Immutable simply means unmodifiable or unchangeable.
As Java uses the concept of String literal. Suppose there are 5 reference variables, all refer to one object "Fruit".
If one reference variable changes the value of the object, it will be affected by all the reference variables. That is why String objects are immutable in Java.

STRINGBUFFER
StringBuffer class is:
        - mutable (modifiable)
        - synchronized and thread-safe (only one thread can call the methods of StringBuffer)
There are many built in methods like: append(), insert(), replace(), delete(), reverse(), charAt(), length(), substring() etc.

STRINGBUILDER (from JDK 1.5)
StringBuilder class is:
        - mutable (modifiable)
        - non- synchronized and not thread safe (multiple threads can call the methods of StringBuilder simultaneously)
There are many built in methods like: append(), insert(), replace(), delete(), reverse(), charAt(), length(), substring() etc.


How to create Immutable class?
There are many immutable classes like String, Boolean, Byte, Short, Integer, Long, Float, Double etc. In short, all the wrapper classes and String class is immutable.
Also, we can create immutable class by creating final class that have final data members.


JAVA COLLECTIONS
========================================================================================================================
01/14/2022 Chirag
Collections
List -->  ordered, resizable
Set --> unordered (no index), unique value
Queue --->
Map --> unordered key-value pair (key instead of index)
========================================================================================================================

Java Collection means a single unit of objects, i.e., a group.
The Collection framework" represents a unified architecture for storing and manipulating a group of objects.
Java Collection framework provides many interfaces and classes.

For Hierarchy of Collection Framework see screenshots!

ITERATOR INTERFACE
Iterator interface provides the FACILITY of iterating the elements in a forward direction only.
There are only three methods in the Iterator interface. They are:
1. hasNext();
2. next()
3. remove(

ITERABLE INTERFACE
The Iterable interface is the root interface for all the "Collection classes (Collection framework".
The Collection interface extends the Iterable interface and therefore all the subclasses of Collection interface also implement the Iterable interface.
It contains only one abstract method:
Iterator<T> iterator(); --> it returns the "iterator" over the elements of type T.

COLLECTION INTERFACE
The Collection interface is the interface which is implemented by all the classes in the collection framework.
It declares the methods that every collection will have.


====================================== LIST INTERFACE ======================================
List interface is the child interface of Collection interface.
List in Java provides the facility to maintain the ORDERED collection.
It contains the index-based methods to insert, update, delete and search the elements.
It can have the duplicate elements also. We can also store the null elements in the list.
List interface is implemented by the classes
    "ArrayList",
    "LinkedList",
    "Vector",
    "Stack".
Its methods:
        add(), addAll(), get(), set(), clear(), remove(), equals(), isEmpty(), iterator(),
        hashCode(), indexOf(), contains(),  replaceAll(), size()..etc.

Difference between List and Set
    A list can contain duplicate elements whereas Set contains unique elements only.

"Synchronized" ---> means only one thread at a time can access the code.
"Non-synchronized" ---> means multiple threads can work on ArrayList at the same time. For example, if one thread is performing an add operation, then there can be
                        another thread performing a remove operation in a multithreading environment.

ARRAYLIST
The ArrayList class implements the "List interface".
Java ArrayList class uses a "dynamic"  array for storing the elements. It is like an array, but there is no size limit.
We can add or remove elements anytime. BY default its size is 10.
So, it is much more flexible than the traditional array. It is found in the java.util package.
The ArrayList in Java can have the duplicate elements also. It implements the List interface so we can use all the methods of List interface here.
The ArrayList maintains the insertion order internally.
It inherits the "AbstractList" class and implements "List" interface.
Points to remember:
    1. ArrayList class maintains insertion order.
    2. In ArrayList we store only Objects not primitive types.
    3. ArrayList class can contain duplicate elements.
    4. ArrayList class is NON-synchronized and non-thread safe (2 and more treads can call its methods simultaneously).
    5. ArrayList allows random access because array works at the index basis.
    6. In ArrayList, manipulation is little bit slower than the LinkedList in Java because a lot of shifting needs to occur if any element is removed from the array list.

Syntax: public class ArrayList<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, Serializable
Constructors of ArrayList:
1. ArrayList(); --> It is used to build an empty array list.
2. ArrayList(Collection<? extends E> c); --> It is used to build an array list that is initialized with the elements of the collection c.
3. ArrayList(int capacity) --> It is used to build an array list that has the specified initial capacity.

"Generic"
Java Collection Framework was non-generic before JDK 1.5. Since 1.5, it is Generic.
ArrayList list=new ArrayList(); //creating old non-generic arraylist
ArrayList<String> list=new ArrayList<String>();//creating new generic arraylist
In a generic collection, we specify the type in angular braces. Now ArrayList is forced to have the only specified type of objects in it.
If you try to add another type of object, it gives compile time error.

LINKEDLIST
LinkedList implements the List interface.
It is a linear data structure where the elements are not stored in contiguous () locations and every element is a separate object with a data and address parts.
The elements are linked using pointers and addresses. Each element is known as a "node".
    - LinkedList can store the duplicate elements.
    - LinkedList maintains the insertion order.
    - LinkedList is NON-synchronized, and non-thread safe (2 and more treads can call its methods simultaneously).
    - In LinkedList, the manipulation is fast because no shifting is required.
    - LinkedList class can be used as a List and Deque.

Syntax: public class LinkedList<E> extends AbstractSequentialList<E> implements List<E>, Deque<E>, Cloneable, Serializable

VECTOR
It is deprecated from Java 1.5 version.
"Vector implements the List interface.
    Vector is like the "dynamic" array which can grow or shrink its size.
    Vector is synchronized and thread-safe (only one thread can  work with Vector).
    Like an Array, Vector contains components that can be accessed using an integer index.
It is similar to the ArrayList, but with two differences:
    - Vector is synchronized.
    - Java Vector contains many "legacy" methods that are not the part of a Collection framework.

STACK
The stack is the subclass of "Vector", it inherits Vector class.
    It implements the LIFO (Last-In-First-Out) data structure.
Methods of stack:
    push() --> Pushes an element on the top of the stack.
    pop() --> Removes and returns the top element of the stack.
    peek() --> Returns the element on the top of the stack, but does not remove it.
    empty() --> It returns true if nothing is on the top of the stack. Else, returns false.


====================================== SET INTERFACE ======================================
A SET is an UNORDERED Collection of objects in which duplicate values cannot be stored.
This collection is used when we wish to avoid the duplication of the objects and wish to store only the unique objects.
The Set interface contains only methods inherited from Collection interface and adds the restriction that duplicate elements are prohibited.
Set is implemented by HashSet, LinkedHashSet, and TreeSet.

HASHSET
HashSet class implements Set interface.
    HashSet stores the elements by using a mechanism called hashing.
    HashSet doesn't maintain the insertion order. Here, elements are inserted on the basis of their hashcode.
    HashSet contains unique elements only.
    HashSet allows NULL value, but only one.
    HashSet class is NON-synchronized.
    The initial default capacity of HashSet is 16.

Syntax: public class HashSet<E> extends AbstractSet<E> implements Set<E>, Cloneable, Serializable

Difference between List and Set
A list can contain duplicate elements whereas Set contains unique elements only.

What is Hashing?
    It is the process of converting an object into an integer value. The integer value helps in indexing and faster searches.

LINKEDHASHSET
A LinkedHashSet inherits a HashSet class and implements Set interface.
The important points about Java LinkedHashSet class are:
        LinkedHashSet class contains unique elements only like HashSet.
        LinkedHashSet class is NON-synchronized.
        LinkedHashSet class maintains insertion order.
        LinkedHashSet allows NULL value, but only one.

Syntax: public class LinkedHashSet<E> extends HashSet<E> implements Set<E>, Cloneable, Serializable

SORTEDSET INTERFACE
This interface is very similar to the "Set interface". The only difference is that this interface has extra methods that maintain the ordering of the elements.
It is used to handle the data which needs to be sorted. The elements of the SortedSet are arranged in the increasing (ascending) (or alphabetical) order.
The class which implements this interface is "TreeSet".

TREESET
TreeSet class implements the Set interface that uses a Tree for storage.
The important points about Java TreeSet class are:
        TreeSet class contains unique elements only like HashSet.
        TreeSet class is NON-synchronized.
        TreeSet class maintains ascending order.
        TreeSet class doesn't allow NULL element.

Syntax: public class TreeSet<E> extends AbstractSet<E> implements NavigableSet<E>, Cloneable, Serializable


QUEUE INTERFACE
A "Queue interface" maintains the FIFO (First In First Out) order similar to a real-world queue line.
This interface is dedicated to storing all the elements where the order of the elements matter.
There are various classes like PriorityQueue, Deque, and ArrayDeque which implements the Queue interface.
The most frequently used class is "PriorityQueue".

PRIORITYQUEUE
A PriorityQueue is used when the objects are supposed to be processed based on the priority. The PriorityQueue is based on the priority heap.
The elements of the priority queue are ordered according to the natural ordering (by default), or by a Comparator provided at queue construction time.
Syntax: 1. Creates a PriorityQueue with the default initial capacity (11) that orders its elements according to their natural ordering.
           PriorityQueue<E> pq = new PriorityQueue<E>();
        2. Creates a PriorityQueue with the specified initial capacity that orders its elements according to the specified comparator.
           PriorityQueue<E> pq = new PriorityQueue(int initialCapacity, Comparator<E> comparator);

DEQUE INTERFACE
Deque interface extends the Queue interface. In Deque, we can remove and add the elements from both the side.
Deque stands for a "double-ended queue" which enables us to perform the operations at both the ends.
The class which implements this interface is "ArrayDeque".

ARRAYDEQUE
ArrayDeque class implements the Deque interface.
This is a special kind of array that grows and allows users to add or remove an element from both sides of the queue.
Array Deques have no capacity restrictions and they grow as necessary to support usage.
The important points about ArrayDeque class are:
        Unlike Queue, we can add or remove elements from both sides.
        Null elements are not allowed in the ArrayDeque.
        ArrayDeque is not thread safe, in the absence of external synchronization.
        ArrayDeque has no capacity restrictions.
        ArrayDeque is faster than LinkedList and Stack.


====================================== MAP INTERFACE ======================================
A MAP contains values on the basis of key, i.e. "key and value" pair. Each key and value pair is known as an "entry". A Map contains unique keys.
A Map is useful if you have to search, update or delete elements on the basis of a key. A Map doesn't allow duplicate keys, but you can have duplicate values.
There are two interfaces for implementing Map in java: "Map" and "SortedMap", and three classes: "HashMap", "LinkedHashMap", and "TreeMap".
Map methods: put(), get(), size(), remove(), keySet(), entrySet(), clear(),
             containsKey(), containsValue(), equals(), hashCode(), isEmpty(), replace() etc.

Map.Entry interface
Entry is the sub-interface of Map. It returns a collection-view of the map, whose elements are of this class.
Its methods: getKey(), getValue().


HashMap and LinkedHashMap allow NULL keys and values, but TreeMap doesn't allow any NULL key or value.
HashMap ---> is the implementation of Map, but it doesn't maintain any order.
LinkedHashMap --->is the implementation of Map. It inherits HashMap class. It maintains insertion order.
TreeMap ---> is the implementation of Map and SortedMap. It maintains ascending order.

HASHMAP
Java HashMap class implements the Map interface which allows us to store key and value pair, where keys should be unique.
If you try to insert the duplicate key, it will replace the element of the corresponding key.
It is easy to perform operations using the key index like updation, deletion, etc. HashMap class is found in the "java.util" package.
HashMap is non-synchronized. It allows us to store the "null" elements as well, but there should be only one null key.
Since Java 5, it is denoted as HashMap<K,V>, where K stands for key and V for value.
Points to remember:
    1. HashMap contains values based on the key.
    2. HashMap contains only unique keys.
    3. HashMap may have one NUL key and multiple NULL values.
    4. HashMap is NON-synchronized.
    5. HashMap is unordered.
    6. The initial default capacity of Java HashMap class is 16.

Syntax: public class HashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>, Cloneable, Serializable

LINKEDHASHMAP
It inherits HashMap class and implements the Map interface.
Points to remember:
    1. LinkedHashMap contains values based on the key.
    2. LinkedHashMap contains unique elements.
    3. LinkedHashMap may have one NULL key and multiple NULL values.
    4. LinkedHashMap is NON-synchronized.
    5. LinkedHashMap maintains insertion order.
    6. The initial default capacity of Java HashMap class is 16.

Syntax: public class LinkedHashMap<K,V> extends HashMap<K,V> implements Map<K,V>

TREEMAP
It implements the NavigableMap interface and extends AbstractMap class.
Points to remember:
    1. TreeMap contains values based on the key.
    2. TreeMap contains only unique elements.
    3. TreeMap cannot have a NULL key but can have multiple NULL values.
    4. TreeMap is NON-synchronized.
    5. TreeMap maintains ascending order.

Syntax: public class TreeMap<K,V> extends AbstractMap<K,V> implements NavigableMap<K,V>, Cloneable, Serializable

What is difference between HashMap and TreeMap?
HashMap can contain one null key.             TreeMap cannot contain any null key.
HashMap maintains no order.                   TreeMap maintains ascending order.











