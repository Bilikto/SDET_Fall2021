// Used site ---> https://www.javatpoint.com

ABOUT JAVA:
- What is Java?
    Java is a programming language and a platform. Java is a high level, robust, object-oriented and secure programming language.
    Java was developed by Sun Microsystems (which is now the subsidiary of Oracle) in the year 1995.
    James Gosling is known as the father of Java.

 A list of important features of Java:
    - Simple language;
    - Object-oriented programming language --> all are objects in Java (class, object + 4 principles);
    - Platform independent (write once, run anywhere ("platform" is hardware and software environment));
    - Secured --> we can develop virus-free systems. Java is secured because Java Programs run inside a virtual machine sandbox.
    - Robust (strong) --> Java uses strong memory management. Garbage collection is implemented.

 There are 4 editions of Java:
    1) Java SE (Java Standard Edition)
       It is a Java programming platform. It includes Java programming APIs such as java.lang, java.io, java.net, java.util, java.sql, java.math etc.
       It includes core topics like OOPs, String, Regex, Exception, Inner classes, Multithreading, I/O Stream, Networking, AWT, Swing, Reflection, Collection, etc.
    2) Java EE (Java Enterprise Edition)
       It is an enterprise platform that is mainly used to develop web and enterprise applications. It is built on top of the Java SE platform.
       It includes topics like Servlet, JSP, Web Services, EJB, JPA, etc.
    3) Java ME (Java Micro Edition)
       It is a micro platform that is dedicated to mobile applications.
    4) JavaFX
       It is used to develop rich internet applications. It uses a lightweight user interface API.


BASICS OF JAVA:
- Compilation Flow:
    javac (HelloWorld.java (Java Code))   -->   Compiler  --> java (HelloWorld.class (Byte Code))

- JDK, JRE and JVM:
    "JVM" (Java Virtual Machine) is an abstract machine. It is called a virtual machine because it doesn't physically exist. It is a specification that provides a
    runtime environment in which Java bytecode can be executed.
    "JRE" (Java Runtime Environment). The JRE is a set of software tools which are used for developing Java applications. It is used to provide the runtime environment.
    It is the implementation of JVM. It physically exists. It contains a set of libraries + other files that JVM uses at runtime.
    "JDK" (Java Development Kit). The JDK is a software development environment which is used to develop Java applications.
    It physically exists. It contains JRE, JVM + development tools (javac, java etc).


VARIABLES:
    A "variable" is a container which holds the value while the Java program is executed. It is a combination of "vary + able" which means its value can be changed.
    A variable is assigned with a data type. Variable is a name of memory location. There are three types of variables in java: local, instance and static.
    - "Local": Variable created inside any blocks (for loop, methods, if condition), or not declared at class level are the local variables
               Local variable can be accessible only inside the blocks where it is created
               Local variable can not be static & can not be private, public
               Local variable must be initialized before use
               Local variable can be final
    - "Instance": Variable created at class level without static keyword are the instance variables
                  It belongs to the objects
                  Instance variable initialized by default (default value for int - 0 & String - null)
                  Instance variable can be private, public
                  Instance variable can be final
                  Instance variable will have multiple copies with respect to number of object we're creating from class
    - "Static": Variable created at class level with static keyword are the Static variables
                It belongs to the class
                Static variable initialized by default (default value for int - 0 & String - null)
                Static variable can be private, public
                Static variable will have single copy at class level regardless of number of object we're creating from class
                Static variable can be final


DATA TYPES:
"Primitive" (8 data types)
byte, short, int, long, double, float, boolean, char.

"Non-Primitive" (reference types)
Classes, Interfaces, and Arrays.


OPERATORS:
There are many types of operators in Java:
"Unary" Operator --> postfix (expr++, expr--)
                 --> prefix (++expr, --expr)
"Arithmetic" Operator --> multiplicative (*, /, %)
                      --> additive (+, -)
"Shift" --> shift (<<, >>, >>>)
"Relational" --> comparison (<, >, <=, >=, instanceof)
             --> equality (==, !=)
"Bitwise" --> AND (&)
          --> exclusive OR (^)
          --> inclusive OR (|)
"Logical" --> AND (&&)
          --> OR (||)
"Ternary" --> ternary (? :)
"Assignment" --> (=, +=, -=, *=, /=, %=, &=, ^=, |=, <<=, >>=, >>>=)


DATA TYPE CASTING:
data type casting --> is converting one data type to another.
- "Implicit" [automatically] -> it happens automatically when we convert from smaller to larger data type;
- "Explicit" [manually] -> when we convert from larger to smaller data type, because we might loose some value in our data
    EX: Explicit type casting - from double to int
        double d1 = 12.34;
        int i = d1 -> incompatible types compile error and in order to fix this we need to manually type cast it as follows
        int i = (int) d1;


AUTOBOXING and UNBOXING:
"Autoboxing" is converting primitive to wrapper class objects;
"Unboxing" is converting from wrapper object to primitive.


CONTROL FLOW STATEMENTS:
Java provides 3 types of control flow statements:
1. Decision Making statements (conditional statements)
    - if, if-else statements
    - switch statements
2. Loop statements
    - do_while loop
    - while loop
    - for loop
    - for_each loop
3. Jump statements
    - break statement
    - continue statement

"Decision Making statements" decide which statement to execute and when. It evaluates condition to Boolean expression.
Ex: if(true) {...}
"Switch" statement supports --> byte, short, int, char, Byte, Short, Integer, Character, String and enumeration.
It doesn`t support --> double, float, boolean.
The case value must be literal or constant! It doesn't allow variables.
Ex: switch(expr) {
        case value1: // --> value1 must be final value! it can not be expression!
            statement1;
            break;
        .
        .
        case valueN:
            statementN;
            break;
        default:
            default statement;
}

"Loop statements" are used to execute the set of instructions in a repeated order.
"for loop": ---> for(int i = 0; i < 10; i++) {..}
We use the "for loop" only when we exactly know the number of times, we want to execute the block of code.

"for-each loop": ---> for(data_type var: array/collection) {...}
Java provides an enhanced for loop to traverse the data structures like array or collection. In the for-each loop, we don't need to update the loop variable.

"while loop" ---> while(condition) {...}
If we don't know the number of iterations in advance, it is recommended to use a "while" loop

"do_while loop" ---> do { statements } while(condition)
When the number of iteration is not known and we have to execute the loop at least once, we can use do-while loop.

"Jump statements" are used to transfer the execution control to the other part of the program.
"break" ---> is used to break the current flow of the program and transfer the control to the next statement outside a loop or switch statement. However, it breaks only
             the inner loop in the case of the nested loop. The break statement cannot be used independently, it can only be written inside the loop or switch statement.
"continue" ---> doesn't break the loop, it skips the specific part of the loop and jumps to the next iteration of the loop immediately.


COMMENTS IN JAVA
Single line comment --> //
Multiline comment   --> /*...*/
Java Documentation comment -->   /**  (usually used to write large programs for a project or software
                                 *    application as it helps to create documentation API)
                                 *
                                 * @author Bilikto
                                 * @version 1.8
                                 * @since 01/05/2022
                                 */

OOP CONCEPTS
 -Object
 -Class
 -Method
 -Constructor
 -Static keyword
 -Types of Variables(Local, Static, Instance)
 -Inheritance
 -Polymorphism
 -Abstraction
 -Encapsulation
There are some other terms which are used in OOP:
 -Coupling (when a class has the details information of another class, it arises when classes are aware of each other)
 -Cohesion (It refers to the level of a component which performs a single well-defined task)
 -Association (It represents the relationship between the objects)
 -Aggregation (It represents the relationship where one object contains other objects as a part of its state. It is also termed as a HAS-A relationship in Java)
 -Composition (The composition represents the relationship where one object contains other objects as a part of its state.  There is a strong relationship between the containing object and the dependent object.
               If you delete the parent object, all the child objects will be deleted automatically)

Object
Objects is any entity that has state abd behaviour (Ex: a chair, pen, table, dog, cat). It is an instance of a class.

Class
Class is collection of objects. It is a blueprint from which you can create an individual object.

Inheritance --> when one object acquires all the properties and behaviors of parent object
	-extends keyword
	-Constructor Chaining
	-"this" keyword
	-"super" keyword

Polymorphism
	-Method Overloading
	-Method Overriding
	-Dynamic Polymorphism / Run Time Polymorphism

Encapsulation
    -Access modifier
    -Getters & Setters

Abstraction
    -Abstract Class
    -Interface

Exception Handling
    -try_catch_finally

Generics
    -<T>

OOP vs PROCEDURE-ORIENTED PROGRAMMING
1. OOPs makes development and maintenance easier, whareas, in a POP it is not easy to mange if code grows as project size increase.
2. OOPs provides data hiding, whereas, in a procedure-oriented programming language, global data can be accessed from anywhere
3. OOPs provides the ability to simulate real-world event much more effectively. We can provide the solution of real word problem if we are using the OOP language.

NAMING CONVENTION
Start with the uppercase letter:
Class --> It should be a noun such as Color, Button, System, Thread, etc.
Interface --> It should be an adjective such as Runnable, Remote, ActionListener.
Start with lowercase letter:
Method --> It should be a verb such as main(), print(), println().
Variable --> It should not start with the special characters like & (ampersand), $ (dollar), _ (underscore).

Package --> It should be a lowercase letter such as java, lang. Multiple words are separated by dots (.) such as java.util.
Constant --> It should be in uppercase letters such as RED, YELLOW. Multiple words are separated an underscore(_) such as MAX_PRIORITY.
 +  camelCase!

OBJECTS
Object is any entity that has state and behavior. Ex: chair, pen, table etc.
An object is an instance of a class.
"State" --> represents the data(value) of an object
"Behavior" --> represents the behaviour(functionality) of an object
"Identity" --> every object has a a unique ID which is used by JVM to identity each object.

CLASS
It is a template or blueprint from which objects are created.
Class contains:
-Fields
-Methods
-Constructors
-Blocks
-Nested class and interface

INSTANCE VARIABLE (from Chirag class)
---> a variable which is created inside the class but outside the method, at class level
---> It doesn't get memory at compile time. It gets memory at runtime when an object or instance is created!
---> It belongs to the objects
---> Instance variable initialized by default (default value for int - 0 & String - null)
---> Instance variable can be private, public
---> Instance variable can be final
---> Instance variable will have multiple copies with respect to number of object we're creating from class


METHOD
In Java, a "method" is a block of code or collection of statements or a set of code grouped together to perform a certain task or operation.
Advantage of Method:
-Code Reusability --> We write a method once and use it many times. We do not require to write code again and again.
-Code Optimization --> we can easily modify code by adding and removing a chunk of code.
Method declaration:
access modifier, return type, methodName, parameterList,, method body.
public int sum(int a, int b) {...body...}

Method signature:
Every method has a "method signature". It is a part of the "method declaration". It includes the method name and parameter list.
Access Modifiers (specifier):
- Public --> The method is accessible by all classes when we use public specifier in our application (even in different packages)
- Private --> The method is accessible only in the classes in which it is defined
- Protected --> The method is accessible within the same package or subclasses in a different package
- Default (Package private) --> The method is visible only from the same package only. It is set by default, when we do not use any access modifiers.

Return Type:
Return type is a data type that the method returns. If the method does not return anything, we use "void" keyword.

There are two types of methods:
1. Predefined (or built-in) methods --> method that is already defined in the Java class libraries (Ex: length(), equals(), compareTo()..);
2. User-defined methods --> method is written by programmer.

Static method
A method that has "static" keyword is known as static method. In other words, a method that belongs to a class rather than an instance
of a class is known as a "static method". The main advantage of a static method is that we can call it without creating an object.
It can access "static" data members and also change the value of it. The best example of a static method is the main() method.

Instance method
The method of the class is known as an "instance method". It is a non-static method defined in the class.
Before calling or invoking the instance method, it is necessary to create an object of its class.
There two types of instance methods:
1. Accessor (or getters) method -->  It is used to get the value of the private field.
2. Mutator (or setters) method --  It is used to set the value of the private field. It does not return anything.

Abstract method
The method that does not has method body is known as "abstract method". In other words, without an implementation is known as "abstract method".
It always declares in the abstract class. If class uses abstract method it MUST be "abstract" Class.
To create an abstract method, we use the keyword "abstract".

Factory method
It is a method that returns an object to the class to which it belongs. All static methods are factory methods.
For example, NumberFormat obj = NumberFormat.getNumberInstance();


========================================================================================================
01/08/2022
Revision class with Chirag!

We can not override static methods it belongs to class!
Ex: Parent p = new Child();
    p.method(); // --> if we the method is overriden parent object "p" will call "static" method of parent class

We can not override variables! // --> parent object will call variable of parent class!

If Constructor is "private" we can not instantiate class.. we will get compilation error!

We can not use static methods and vars inside methods. Only at Class level.

We can not call from static methods non - static method and variables.
========================================================================================================


"NEW" Keyword
The new keyword is used to allocate memory at runtime. All objects get memory in Heap memory area.

3 ways to INITIALIZE object
1. By reference variable
    Ex:  Student s1=new Student();
         s1.id=101;
2. By method
    Ex:  Student s1=new Student();
         s1.initializerMethod(101);
3. By constructor

5 ways TO CREATE an object
1. By new keyword
2. By newInstance() method
3. By clone() method
4. By deserialization
5. By factory method


ANONYMOUS OBJECT
Anonymous simply means nameless. An object which has no reference is known as an anonymous object. It can be used at the time of object creation only.
If you have to use an object only once, an anonymous object is a good approach.
Ex: new Calculator().method(); //we can call method through anonymous object


CONSTRUCTOR
Constructor is a block of codes similar to the method. It is called when an instance of the class is created.
At the time of calling constructor, memory for the object is allocated in the memory.
Constructor is used to initialize the object.
Every time when an object is created using the "new" keyword, at least one constructor is called.
1. "Default" constructor --> if there is no constructor available in the class.
2. "No-arg" constructor --> explicit constructor added by developer. We can write any statements inside explicit constructor
3. "Parametrized" constructor --> explicit constructor added by developer which takes parameter from user.
                                When we create an object of class we have to pass parameters to the constructor.

Constructor RULES:
1. Constructor name must be the same as its class name.
2. A Constructor must not have return type.
3. A Constructor cannot be abstract, static, final and synchronized.
4. A Constructor can have access modifier - public, private, protected, default .

What is the purpose of a default constructor?
The default constructor is used to provide the default values to the object like 0, null, etc., depending on the type.
Why use the parameterized constructor?
The parameterized constructor is used to provide different values to distinct objects. However, you can provide the same values also.

Constructor overloading
"Constructor overloading" in Java is a technique of having more than one constructor with different parameter lists.

STATIC KEYWORD
The "static" keyword in Java is used for memory management mainly (it saves memory).
We can use "static" keyword with:
 1.variables,   3. blocks,
 2. methods,    4. nested classes.
The static keyword belongs to the class than an instance of the class.

Static variable
Any variable with static keyword is known as "static variable".
It'll create single copy at class level regardless of how many objects we're creating from class. Example - Family Income or College name of students.
The static variable gets memory only once in the class area at the time of class loading.
Java static variable is shared to all objects !!!
 EX:
    1. Program of the counter with NON-static variable
    In this example, we have created an instance variable named count which is incremented in the constructor.
    Since instance variable gets the memory at the time of object creation, each object will have the copy of the instance variable.
    class Counter{
        int count=0; //will get memory each time when the instance is created
        Counter(){
            count++;//incrementing value
            System.out.println(count);
        }

        public static void main(String args[]){
            Counter c1=new Counter(); //1
            Counter c2=new Counter(); //1
            Counter c3=new Counter(); //1
        }
    }
    Output: 1, 1, 1

    2. Program of counter by STATIC variable
    class Counter{
        static int count=0; //will get memory only once and retain its value
        Counter(){
            count++;//incrementing value
            System.out.println(count);
        }

        public static void main(String args[]){
            Counter c1=new Counter(); //1
            Counter c2=new Counter(); //2
            Counter c3=new Counter(); //3
        }
    }
    Output: 1, 2, 3

Static Variables (from Chirag class)
---> Variable created at class level with static keyword are the Static variables
---> It belongs to the class
---> Static variable initialized by default (default value for int - 0 & String - null)
---> Static variable can be private, public
---> Static variable will have single copy at class level regardless of number of object we're creating from class
---> Static variable can be final

*** Instance variable will get created in the memory when we create an object of the class
*** We don't required to create an object to call the static methods

Static method
If you apply static keyword with any method, it is known as "static method".
 - A static method belongs to the class rather than the object of a class.
 - A static method can be invoked without the need for creating an instance of a class.
 - A static method can access ONLY static data member and can change the value of it.
Restrictions for static methods:
1. The static method can not use non static data member or call non-static method directly
2. "this" and "super" cannot be used in static context.

Static block
 - Is used to initialize the static data member.
 - It is executed before the main method at the time of classloading.
Ex: class A2{
      static{System.out.println("static block is invoked");}
      public static void main(String args[]){
       System.out.println("Hello main");
      }
    }
Output: static block is invoked
        Hello main

LOCAL VARIABLES
---> Variable created inside any blocks (for loop, methods, if condition), or not declared at class level are the local variables
---> Local variable can be accessible only inside the blocks where it is created
---> Local variable can not be static & can not be private, public
---> Local variable must be initialized before use
---> Local variable can be final


"THIS" KEYWORD
(from Chirag class)
---> It's reference variable that refers to the current object
---> This keyword can be used to access current class instance variables & methods
---> this() keyword also used to call current class constructor from another current class constructor

Rules of calling current class constructor from another constructor :
1. this() --> will call no argument constructor & IT SHOULD BE THE FIRST STATEMENT ONLY
2. this("data") --> will call parameterized constructor with String parameter

Here is given the 6 usage of java "this" keyword:
  1. this can be used to refer current class instance variable
  2. this can be used to invoke current class method (implicitly)
  3. this() can be used to invoke current class constructor.
  4. this can be passed as an argument in the method call.
  5. this can be passed as argument in the constructor call.
  6. this can be used to return the current class instance from the method.

Using "this" keyword we can distinguish local variable (parameters) and instance variable. Ex: this.name = name;
If local variables(arguments) and instance variables are different, there is no need to use this keyword.

You may invoke the method of the current class by using the this keyword.
If you don't use the this keyword, compiler automatically adds this keyword while invoking the method.

The this() constructor call can be used to invoke the current class constructor. It is used to reuse the constructor.
In other words, it is used for constructor chaining.

Rule: Call to this() must be the first statement in constructor!

this: to pass as an argument in the method
The this keyword can also be passed as an argument in the method. It is mainly used in the event handling.
Ex: class S2{
      void m(S2 obj){
        System.out.println("method is invoked");
      }
      void p(){
        m(this);
      }
      public static void main(String args[]){
        S2 s1 = new S2();
        s1.p();
      }
    }
Output: method is invoked

this: to pass as argument in the constructor call
We can pass the this keyword in the constructor also. It is useful if we have to use one object in multiple classes.
Ex: class B{
        A4 obj;
        B(A4 obj){
            this.obj=obj;
        }
        void display(){
            System.out.println(obj.data);//using data member of A4 class
        }
    }

    class A4{
        int data=10;
        A4(){
            B b=new B(this);
            b.display();
        }
        public static void main(String args[]){
        A4 a=new A4();
        }
    }
Output: 10

this: can be used to return current class instance
We can return this keyword as an statement from the method. In such case, return type of the method must be the class type (non-primitive).
Ex: lass A{
        A getA(){ <--- method with return type!
        return this;
        }
        void msg(){System.out.println("Hello java");}
    }
    class Test1{
        public static void main(String args[]){
            new A().getA().msg();
        }
    }
Output: Hello java

INHERITANCE (IS-A)
"Inheritance" in Java is a mechanism in which one object acquires all the properties and behaviors of a parent object. It is an important part of OOP.
When you inherit from an existing class, you can reuse methods and fields of the parent class. Moreover, you can add new methods and fields in your current class also.
Inheritance represents the "IS-A" relationship which is also known as a parent-child relationship. Ex: Bird IS-A Animal (It means that Bird is a type of Animal)
Why use inheritance in java?
1. For Method Overriding (so runtime polymorphism can be achieved).
2. For Code Reusability.

How can we achieve inheritance in java - Using "extends" keyword.
The meaning of "extends" is to increase the functionality.

NOTE!
In java programming, multiple inheritance is not supported through "class" byu multiple inheritance is supported through "interface" only!

Aggregation (HAS-A)
If a class have an entity reference, it is known as "Aggregation". Aggregation represents "HAS-A" relationship.
For example, Employee object contains many informations such as id, name, emailId etc. It contains one more object named Address, which contains
its own informations such as city, state, country, zipcode etc. as given below.
class Employee{
    int id;
    String name;
    Address address;  // Address is a class
    ...
}
In such case, Employee has an entity reference address, so relationship is Employee HAS-A address.

Why use Aggregation?
- For Code Reusability, when there is no is-a relationship.

ConstructorChaining (from Chirag class)
---> When we create object of child class it'll call parent class constructor first & then it'll call
child class constructor. This is called "Constructor Chaining".
---> For Example we have parent class A---> B (child of A) ---> C (child of B)
---> When we create object of class C then it'll call constructor of A first & then constructor of B and then it'll call constructor of C.


POLYMORPHISM

"METHOD OVERLOADING"
"Method Overloading" --> when a class has multiple methods with same name but different parameters.
Advantage of method overloading:
- Method overloading increases the readability of the program.
There are two ways to overload the method in java
1. By changing number of arguments
2. By changing the data type
In Java, Method Overloading is not possible by changing the return type of the method only.

Can we overload java main() method?
Yes, by method overloading. You can have any number of main methods in a class by method overloading.
But JVM calls main() method which receives string array as arguments only!

Method Overloading and Type Promotion
One type is promoted to another implicitly if no matching datatype is found.
The "byte" can be promoted to short, int, long, float or double.
The "short" datatype can be promoted to int, long, float or double.
The "char" datatype can be promoted to int,long,float or double and so on.
If there are matching type arguments in the method, type promotion is not performed!!!

"METHOD OVERRIDING"
"Method overriding" --> when a subclass (child class) has the same method as declared in the parent class.
In other words, If a subclass provides the specific implementation of the method that has been declared by one of its parent class, it is known as "method overriding".
Usage of Java Method Overriding
- Method overriding is used to provide the specific implementation of a method which is already provided by its superclass.
- Method overriding is used for runtime polymorphism

Rules for Java Method Overriding:
1. The method must have the same name as in the parent class
2. The method must have the same parameter as in the parent class.
3. There must be an IS-A relationship (inheritance).

Can we override static method?
No, a static method cannot be overridden. It is because the static method is bound with class whereas instance method is bound with an object.
Static belongs to the class area, and an instance belongs to the heap area.

Difference between "method overloading" and "method overriding"
        "Method Overloading"                                                               "Method Overriding"
1. Method overloading is used to increase the "readability"                1. Method overriding is used "to provide the specific implementation of the method"
   of the program.                                                            that is already provided by its super class.
2. Method overloading is performed within class.                           2. Method overriding occurs in two classes that have IS-A (inheritance) relationship.
3. In case of method overloading, parameter must be different.             3. In case of method overriding, parameter must be same.
4. Method overloading is the example of "COMPILE TIME" polymorphism.       4. Method overriding is the example of "RUN TIME" polymorphism.
5.  Return type can be same or different in method overloading.            5. Return type must be same or covariant in method overriding.

"COVARIANT Return Type"
Before Java5, it was not possible to override any method by changing the return type. But now, since Java5, it is possible to override method by changing the return type
if subclass overrides any method whose return type is Non-Primitive but it changes its return type to subclass type.
Ex: class A{
        A get(){return this;}
    }

    class B1 extends A{
        @Override
        B1 get(){        // ---> if I write here A get() {..} in the main method we need to typecasting like ((B1)B1().get()).message();
            return this;
        }
        void message(){
            System.out.println("welcome to covariant return type");
        }

        public static void main(String args[]){
            new B1().get().message();
        }
    }
Output: welcome to covariant return type
In this example, the return type of the get() method of A class is A but the return type of the get() method of B class is B.
Both methods have different return type but it is method overriding. This is known as "covariant return type".
Advantages:
1. Covariant return type assists to stay away from the confusing type casts in the class hierarchy and makes the code more usable, readable, and maintainable.
2. In the method overriding, the covariant return type provides the liberty to have more to the point return types.
3. Covariant return type helps in preventing the run-time ClassCastExceptions on returns.


SUPER KEYWORD
1) It's a reference variable refers to object of parent class
2) Super keyword can be used to access parent class variables & methods
3) Super keyword also used to call parent class constructor from child class constructor

The super keyword in Java is a reference variable which is used to refer immediate parent class object.
Whenever you create the instance of subclass, an instance of parent class is created implicitly which is referred by super reference variable
Usage of Java super Keyword
1. super can be used to refer immediate parent class instance variable. --> if parent class and child class have same variables
2. super can be used to invoke immediate parent class method. --> It should be used if subclass contains the same method as parent class (overridden method).
3. super() can be used to invoke immediate parent class constructor. --> if there is no super() or this() it will added in each class constructor automatically by compiler.





















JAVA COLLECTIONS
===================================================================
01/14/2022
Chirag
Collections
List -->  ordered, resizable
Set --> unordered (no index), unique value
Map --> unordered key-value pair (key instead of index)
===================================================================

"Java Collection" means a single unit of objects, i.e., a group.
The "Collection framework" represents a unified architecture for storing and manipulating a group of objects.
Java Collection framework provides many interfaces and classes.

For Hierarchy of Collection Framework see screenshots!

"ITERATOR INTERFACE"
Iterator interface provides the facility of iterating the elements in a forward direction only.
There are only three methods in the Iterator interface. They are:
1. hasNext();
2. next()
3. remove(

"ITERABLE INTERFACE"
The Iterable interface is the root interface for all the "Collection classes (Collection framework".
The Collection interface extends the Iterable interface and therefore all the subclasses of Collection interface also implement the Iterable interface.
It contains only one abstract method:
Iterator<T> iterator(); --> it returns the "iterator" over the elements of type T.

"COLLECTION INTERFACE"
The Collection interface is the interface which is implemented by all the classes in the collection framework.
It declares the methods that every collection will have.

"LIST INTERFACE"
List interface is the child interface of "Collection interface".
This interface is dedicated to the data of the list type in which we can store all the ordered collection of the objects.
It can have duplicate values.
List interface is implemented by the classes "ArrayList", "LinkedList", "Vector", and "Stack".

"Synchronized" ---> means only one thread at a time can access the code.
"Non-synchronized" ---> means multiple threads can work on ArrayList at the same time. For example, if one thread is performing an add operation,
then there can be another thread performing a remove operation in a multithreading environment.

"ArrayList"
The ArrayList class implements the "List interface".
Java ArrayList class uses a "dynamic" array for storing the elements. It is like an array, but there is no size limit. We can add or remove elements anytime.
So, it is much more flexible than the traditional array.  It is found in the java.util package.
The ArrayList in Java can have the duplicate elements also. It implements the List interface so we can use all the methods of List interface here.
The ArrayList maintains the insertion order internally.
It inherits the "AbstractList" class and implements "List" interface.
Points to remember:
1. Java ArrayList class can contain duplicate elements.
2. Java ArrayList class maintains insertion order.
3. Java ArrayList class is non-synchronized.
4. Java ArrayList allows random access because array works at the index basis.
5. In ArrayList, manipulation is little bit slower than the LinkedList in Java because a lot of shifting needs to occur if any element is removed from the array list.

Syntax: public class ArrayList<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, Serializable
Constructors of ArrayList:
1. ArrayList(); --> It is used to build an empty array list.
2. ArrayList(Collection<? extends E> c); --> It is used to build an array list that is initialized with the elements of the collection c.
3. ArrayList(int capacity) --> It is used to build an array list that has the specified initial capacity.

"Generic"
Java collection framework was non-generic before JDK 1.5. Since 1.5, it is generic.
ArrayList list=new ArrayList(); //creating old non-generic arraylist
ArrayList<String> list=new ArrayList<String>();//creating new generic arraylist
In a generic collection, we specify the type in angular braces. Now ArrayList is forced to have the only specified type of objects in it.
If you try to add another type of object, it gives compile time error.


"LinkedList"
LinkedList implements the List interface.
It is a linear data structure where the elements are not stored in contiguous locations and every element is a separate object with a data part and address part.
The elements are linked using pointers and addresses. Each element is known as a "node".
It can store the duplicate elements. It maintains the insertion order. In LinkedList, the manipulation is fast because no shifting is required.

"Vector"
"Vector implements the List interface. Vector implements a dynamic array that means it can grow or shrink as required. It is synchronized.
Like an array, it contains components that can be accessed using an integer index.


"Stack"
The stack is the subclass of "Vector". It implements the LIFO(last-in-first-out) data structure.

"QUEUE INTERFACE"
A "Queue interface" maintains the FIFO(First In First Out) order similar to a real-world queue line.
This interface is dedicated to storing all the elements where the order of the elements matter.
There are various classes like PriorityQueue, Deque, and ArrayDeque which implements the Queue interface.
The most frequently used class is "PriorityQueue".

"PriorityQueue"
A PriorityQueue is used when the objects are supposed to be processed based on the priority. It is known that a queue follows the FIFO algorithm,
but sometimes the elements of the queue are needed to be processed according to the priority and this class is used in these cases.
The PriorityQueue is based on the priority heap.

"DEQUE INTERFACE"
Deque interface extends the Queue interface. In Deque, we can remove and add the elements from both the side.
Deque stands for a "double-ended queue" which enables us to perform the operations at both the ends.
The class which implements this interface is "ArrayDeque".

"ArrayDeque"
ArrayDeque class implements the "Deque interface".
This is a special kind of array that grows and allows users to add or remove an element from both sides of the queue.
Array deques have no capacity restrictions and they grow as necessary to support usage.

"SET INTERFACE"
A set is an unordered collection of objects in which duplicate values cannot be stored. This collection is used when we wish to avoid the duplication of the objects
and wish to store only the unique objects. Set is implemented by HashSet, LinkedHashSet, and TreeSet.

"HashSet"
HashSet class implements Set Interface. It represents the collection that uses a hash table for storage.
The objects that we insert into the HashSet do not guarantee to be inserted in the same order. The objects are inserted based on their hashcode.
This class also allows to insert NULL element, but only one!

"LinkedHashSet"
A LinkedHashSet is very similar to a "HashSet". The difference is that this uses a doubly linked list to store the data and retains (сохраняется) the ordering of the elements.

"SORTEDSET INTERFACE"
This interface is very similar to the "Set interface". The only difference is that this interface has extra methods that maintain the ordering of the elements.
It is used to handle the data which needs to be sorted. The elements of the SortedSet are arranged in the increasing (ascending) (or alphabetical) order.
The class which implements this interface is "TreeSet".

"TreeSet"
TreeSet class implements the "Set interface" that uses a "Tree" for storage. Like HashSet, TreeSet also contains unique elements.
However, the access and retrieval time of TreeSet is quite fast. The elements in TreeSet stored in ascending order.




MAP INTERFACE
A map contains values on the basis of key, i.e. "key and value" pair. Each key and value pair is known as an "entry". A Map contains unique keys.
A Map is useful if you have to search, update or delete elements on the basis of a key.
There are two interfaces for implementing Map in java: "Map" and "SortedMap", and three classes: "HashMap", "LinkedHashMap", and "TreeMap".
A Map doesn't allow duplicate keys, but you can have duplicate values. HashMap and LinkedHashMap allow null keys and values, but TreeMap doesn't allow any null key or value.
"HashMap" ---> is the implementation of Map, but it doesn't maintain any order.
"LinkedHashMap" --->is the implementation of Map. It inherits HashMap class. It maintains insertion order.
"TreeMap" ---> is the implementation of Map and SortedMap. It maintains ascending order.

"Map.Entry" Interface
Entry is the sub-interface of Map. It returns a collection-view of the map, whose elements are of this class. It provides methods to get key and value.

"HashMap"
Java HashMap class implements the Map interface which allows us to store key and value pair, where keys should be unique.
If you try to insert the duplicate key, it will replace the element of the corresponding key.
It is easy to perform operations using the key index like updation, deletion, etc. HashMap class is found in the "java.util" package.
HashMap is non-synchronized. It allows us to store the "null" elements as well, but there should be only one null key.
Since Java 5, it is denoted as HashMap<K,V>, where K stands for key and V for value.

Points to remember:
1. Java HashMap contains values based on the key.
2. Java HashMap contains only unique keys.
3. Java HashMap may have one null key and multiple null values.
4. Java HashMap is non synchronized.
5. Java HashMap maintains no order.
6. The initial default capacity of Java HashMap class is 16 with a load factor of 0.75.

You cannot store duplicate keys in HashMap. However, if you try to store duplicate key with another value, it will replace the value!!!

"LinkedHashMap"
It inherits HashMap class and implements the Map interface.

Points to remember:
1. Java LinkedHashMap contains values based on the key.
2. Java LinkedHashMap contains unique elements.
3. Java LinkedHashMap may have one null key and multiple null values.
4. Java LinkedHashMap is non-synchronized.
5. Java LinkedHashMap maintains insertion order.
6. The initial default capacity of Java HashMap class is 16 with a load factor of 0.75.

Syntax: public class LinkedHashMap<K,V> extends HashMap<K,V> implements Map<K,V>

"TreeMap"
Points to remember:
1. Java TreeMap contains values based on the key. It implements the NavigableMap interface and extends AbstractMap class.
2. Java TreeMap contains only unique elements.
3. Java TreeMap cannot have a null key but can have multiple null values.
4. Java TreeMap is non-synchronized.
5. Java TreeMap maintains ascending order.

Syntax: public class TreeMap<K,V> extends AbstractMap<K,V> implements NavigableMap<K,V>, Cloneable, Serializable











